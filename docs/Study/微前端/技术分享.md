## 参考资源
- [微前端](https://swearer23.github.io/micro-frontends/)
- [微前端从入门到精通](https://juejin.cn/column/7117245118465179661)
- [微前端实践指北](https://juejin.cn/post/7069566144750813197)
- [qiankun](https://qiankun.umijs.org/zh/guide)
## 流程
1. 什么是微前端,微前端的主要特征,适用场景
2. 微前端常见解决方案及优缺点
  - ifram
  - single-spa
  - qiankun
  - miacro-app
3. qiankun的使用
  - 实现方式
4. 结合实际情况分析公司项目是否适用微前端、项目是否需要使用微前端
  - 下单平台中内嵌收银台和cs-chat这种情况
  - ops2技术老旧,如果渐进式重构就需要采用iframe这种形式
## 微前端
### 微前端定义
  - 微前端不是特指某一项技术，而是一种思想。是由2016年 ThoughtWorks Technology Radar 中提出的，借鉴后端微服务的架构模式，将 Web 应用由单一的单体应用转变为多个小型前端应用，聚合为一的应用。
  - 所以微前端不是指具体的库，不是指具体的框架，不是指具体的工具，而是一种理想与架构模式。
  - 微前端的核心三大原则就是：独立运行、独立部署、独立开发 所以满足这些的最佳人选就是 “iframe”!!!
- **单体巨石前端应用**
  - 现代的前端应用的发展趋势正在变得越来越富功能化，富交互化，也就是传说中的SPA(单页面应用)；这样越来越复杂的单体前端应用，背后的后端应用则是数量庞大的微服务集群。被一个团队维护的前端项目，随着时间推进，会变得越来越庞大，越来越难以维护。所以我们给这种应用起名为巨石单体应用。
  ![单体巨石前端应用](https://swearer23.github.io/micro-frontends/ressources/diagrams/organisational/monolith-frontback-microservices.png)
- **面向垂直划分系统的前端架构**
  - 微前端背后的思想是认为：现代复杂的web app或者网站，通常由很多 相对独立的功能模块组合而成，而对这些模块负责的应该是 相互独立的多个团队。这些独立的团队由于专业分工不同，会负责着 特定的业务领域，以及完成 特定的开发任务。这样的团队，通常在人员组成方面囊括了从前端开发到服务端开发，从UI实现到数据库设计这样 端到端 的 跨职能人员 构成。
  - 微前端之类的思路，会被称为 面向垂直划分系统的前端集成。
  ![面向垂直划分系统的前端架构](https://swearer23.github.io/micro-frontends/ressources/diagrams/organisational/verticals-headline.png)
### 微前端架构背后的核心思维
- **技术不可知主义**
  每个团队应该选择自己的技术栈以及技术进化路线，而不是与其他团队步调一致。在项目中可以通过引入自定义元素来提供技术栈无关的接口，同时还隐藏了复杂的内部实现。也许在微前端的语境之下，框架将不是未来架构师主要考虑的问题，如何高效的提供可复用的WebComponent会成为核心问题。
- **隔离团队之间的代码**
  即便所有团队都使用同样的框架，也不要共享同一个运行时环境。构建自包含的Apps。不要依赖共享的状态或者全局变量。
- **建立团队自己的前缀**
  在还不能做到完全隔离的环境下，通过命名规约进行隔离。对于CSS， 事件，Local Storage 以及 Cookies之类的环境之下，通过命名空间进行的隔离可以避免冲突，以及所有权。
- **原生浏览器标准优先于框架封装的API**
  使用 用于通信的原生浏览器事件机制 ，而不是自己构建一个PubSub系统。如果确实需要设计一个跨团队的通信API，那么也尽量让设计简单为好。
- **构建高可用的网络应用**
  即便在Javascript执行失败的情况下，站点的功能也应保证可用。使用同构渲染以及渐进增强来提升体验和性能
### 微前端适用场景
- 微前端架构旨在解决单体应用在一个相对长的时间跨度下，由于参与的人员、团队的增多、变迁，从一个普通应用演变成一个巨石应用(Frontend Monolith)后，随之而来的应用不可维护的问题。这类问题在企业级 Web 应用中尤其常见。

## 微前端常见解决方案及优缺点
- ifram
- single-spa
- qiankun
- miacro-app

## qiankun的实践
### 创建主应用和微应用
- 用vue2创建主应用基座main
- vue2创建微应用vue2-app
- vue2创建微应用vue3-app
- react创建微应用react-app
- jq创建微应用static-app
### 构建主应用基座
- 引入qiankun
- 注册微应用
```javascript
  registerMicroApps(
  /**
   * name: 微应用名称 - 具有唯一性
   * entry: 微应用入口 - 通过该地址加载微应用
   * container: 微应用挂载节点(选择器) - 微应用加载完成后将挂载在该节点上
   * activeRule: 微应用触发的路由规则 - 触发路由规则后将加载该微应用
   * 当匹配到activeRule规则时,获取entry资源,渲染到container容器中
   */
  [
    {
      name: "ReactMicroApp",
      entry: REACT_MICRO_APP,
      container: "#frame",
      activeRule: "/react",
    },
  ]
  )
```
registerMicroApps
- 启动微应用
### 微应用接入改造
以vue2.0为例
- 导出3个必要的生命周期函数
  - bootstrap: 渲染之前
  - mount: 渲染函数
  - unmount: 卸载函数
- 创建public-path.js文件
```javascript
if (window.__POWERED_BY_QIANKUN__) {
  // 动态设置 webpack publicPath，防止资源加载出错
  // eslint-disable-next-line no-undef
  __webpack_public_path__ = window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;
}
```
- 配置 vue.config.js



### Why Not Iframe
- [Why Not Iframe](https://www.yuque.com/kuitos/gky7yw/gesexv)
### 特性
- 📦 基于 single-spa 封装，提供了更加开箱即用的 API。
- 📱 技术栈无关，任意技术栈的应用均可 使用/接入，不论是 React/Vue/Angular/JQuery 还是其他等框架。
- 💪 HTML Entry 接入方式，让你接入微应用像使用 iframe 一样简单。
- 🛡​ 样式隔离，确保微应用之间样式互相不干扰。
- 🧳 JS 沙箱，确保微应用之间 全局变量/事件 不冲突。
- ⚡️ 资源预加载，在浏览器空闲时间预加载未打开的微应用资源，加速微应用打开速度。
- 🔌 umi 插件，提供了 @umijs/plugin-qiankun 供 umi 应用一键切换成微前端架构系统。

